-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- Enable authentication schema
create schema if not exists auth;

-- Drop existing tables if they exist
drop table if exists "public"."reviews" cascade;
drop table if exists "public"."recommendations" cascade;
drop table if exists "public"."user_anime" cascade;
drop table if exists "public"."anime" cascade;
drop table if exists "public"."profiles" cascade;

-- Create auth.users if not exists (mock for development)
create table if not exists auth.users (
    id uuid primary key default uuid_generate_v4(),
    email text unique,
    raw_user_meta_data jsonb default '{}'::jsonb
);

-- Create anime table
create table "public"."anime" (
    "id" bigint generated by default as identity primary key,
    "title" text not null,
    "synopsis" text,
    "image_url" text,
    "mal_id" integer unique,
    "genres" text[],
    "themes" text[],
    "score" numeric(3,2),
    "episodes" integer,
    "status" text,
    "created_at" timestamp with time zone default timezone('utc'::text, now()) not null,
    "updated_at" timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create profiles table
create table "public"."profiles" (
    "id" uuid references auth.users not null primary key,
    "username" text unique,
    "avatar_url" text,
    "bio" text,
    "favorite_genres" text[] default array[]::text[],
    "preferred_themes" text[] default array[]::text[],
    "created_at" timestamp with time zone default timezone('utc'::text, now()) not null,
    "updated_at" timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create user_anime table (replaces watch_list)
create table "public"."user_anime" (
    "id" uuid default uuid_generate_v4() primary key,
    "user_id" uuid references public.profiles(id) not null,
    "anime_id" bigint references public.anime(id) not null,
    "status" text check (status in ('watching', 'completed', 'plan_to_watch', 'dropped')),
    "progress" integer default 0,
    "rating" smallint check (rating >= 1 and rating <= 10),
    "created_at" timestamp with time zone default timezone('utc'::text, now()) not null,
    "updated_at" timestamp with time zone default timezone('utc'::text, now()) not null,
    unique ("user_id", "anime_id")
);

-- Create reviews table
create table "public"."reviews" (
    "id" uuid default uuid_generate_v4() primary key,
    "user_id" uuid references public.profiles(id) not null,
    "anime_id" bigint references public.anime(id) not null,
    "content" text not null,
    "rating" smallint check (rating >= 1 and rating <= 10),
    "created_at" timestamp with time zone default timezone('utc'::text, now()) not null,
    "updated_at" timestamp with time zone default timezone('utc'::text, now()) not null,
    unique ("user_id", "anime_id")
);

-- Create recommendations table
create table "public"."recommendations" (
    "id" uuid default uuid_generate_v4() primary key,
    "user_id" uuid references public.profiles(id) not null,
    "anime_id" bigint references public.anime(id) not null,
    "score" numeric(4,3),
    "reason" text,
    "created_at" timestamp with time zone default timezone('utc'::text, now()) not null,
    "updated_at" timestamp with time zone default timezone('utc'::text, now()) not null,
    unique ("user_id", "anime_id")
);

-- Create RLS policies
create policy "Public profiles are viewable by everyone"
    on profiles for select
    using (true);

create policy "Users can update their own profile"
    on profiles for update
    using (auth.uid() = id);

create policy "Users can view any user_anime entry"
    on user_anime for select
    using (true);

create policy "Users can modify their own user_anime entries"
    on user_anime for all
    using (auth.uid() = user_id);

create policy "Reviews are viewable by everyone"
    on reviews for select
    using (true);

create policy "Users can modify their own reviews"
    on reviews for all
    using (auth.uid() = user_id);

create policy "Recommendations are viewable by target user"
    on recommendations for select
    using (auth.uid() = user_id);

create policy "System can create recommendations"
    on recommendations for insert
    with check (true);

-- Create functions
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, username, avatar_url)
  values (new.id, new.raw_user_meta_data->>'username', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$;

-- Create trigger for new user
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Create indexes
create index idx_anime_mal_id on anime(mal_id);
create index idx_user_anime_user_id on user_anime(user_id);
create index idx_user_anime_anime_id on user_anime(anime_id);
create index idx_reviews_anime_id on reviews(anime_id);
create index idx_recommendations_user_id on recommendations(user_id);
create index idx_recommendations_anime_id on recommendations(anime_id);

-- Enable Row Level Security
alter table "public"."profiles" enable row level security;
alter table "public"."user_anime" enable row level security;
alter table "public"."reviews" enable row level security;
alter table "public"."recommendations" enable row level security;

-- Set up auth helper functions
create or replace function auth.email()
returns text
language sql stable
as $$
  select nullif(current_setting('request.jwt.claim.email', true), '')::text;
$$;

create or replace function auth.uid()
returns uuid
language sql stable
as $$
  select nullif(current_setting('request.jwt.claim.sub', true), '')::uuid;
$$;

create or replace function auth.role()
returns text
language sql stable
as $$
  select nullif(current_setting('request.jwt.claim.role', true), '')::text;
$$;

-- Create trigger function for updating timestamps
create or replace function public.handle_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = current_timestamp;
  return new;
end;
$$;

-- Add update timestamp triggers to all tables
create trigger handle_updated_at
  before update on public.profiles
  for each row
  execute procedure public.handle_updated_at();

create trigger handle_updated_at
  before update on public.anime
  for each row
  execute procedure public.handle_updated_at();

create trigger handle_updated_at
  before update on public.user_anime
  for each row
  execute procedure public.handle_updated_at();

create trigger handle_updated_at
  before update on public.reviews
  for each row
  execute procedure public.handle_updated_at();

create trigger handle_updated_at
  before update on public.recommendations
  for each row
  execute procedure public.handle_updated_at();
